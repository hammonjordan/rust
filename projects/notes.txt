hello_world>main.rs

// 'fn' = function.
// 'main' is the name of the function
// No arguments are currently being passed through the function.
// The 'main' function is always the first code that runs in every executable Rust program.
// The code inside the function are called parameters.
// This line is printing the text, "Hello, World!" in this case, onto the screen.
// Rust style is to indent with four spaces.
// 'println!' calls a Rust 'macro'.
// If the line was calling a function, there wouldn't be an '!', it would read, 'println'.
// 'Hello, World!' is a string being passed as an argument, and the string is being printed on the screen.
// Most lines end with a ';'. A semicolon indicates that the expression is over. 
// In Rust, compiling and running are a seperate step.
// To compile in Rust, we use the line 'rustc program_name.rs', in this case, 'rustc main.rs'.
// 'ls' stands for 'list'.
// There are three files after the program_name.rs file is compiled.
// The files are 'program_name.rs', 'program_name.exe', and 'program_name.pdb'.
// The 'program_name.rs' is the src code file.
// The 'program_name.exe' is the executable code file.
// The 'program_name.pdb' is a file that contains debugging information.

hello_cargo>src>main.rs

// A Rust program can be built using Cargo, with the line, "cargo new 'program_name'", in this case 'cargo new hello_cargo'.
// 'cd program_name' can be used to change the directory to 'program_name'.
// Cargo expects all source files to be located in the 'src' folder.
// If a project that might use Cargo, it is much easier to start by building the project with Cargo.
// Cargo has a built-in compiler. It can be run using the line, 'cargo build'.
// This command create a 'program_name.exe' file.
// Cargo puts the binary in a directory name 'debug'.
// The executable code can be run with the line, './target/debug/program_name', or in this case, './target/debug/hello_cargo'.
// To run the executable code in one line, we can use the line, 'cargo run'.
// 'cargo check' can be used to check if the file can be compiled, but doesn't create an executable.
// If there hasn't been any changes to the code, Cargo won't rebuild, but will run the program.

hello_cargo>Cargo.toml

# [package] is refering to a section heading that indicates that the following statements are configuring a package.
# The next three line under [package] set the configuring information Cargo needs to compile the program.
# The name, the version, and the edition of Rust to use.
# In Rust, packages of code are reffered to as 'crates'.
# [dependencies] is refering to the start of a section heading that indicate the following statements are configuring a dependency.
# Several crates can be added to the project under a [dependencies] section. 

guessing_game>src>main.rs

// rand::Rng package was linked in the 'Cargo.toml' file.
// Rng is a trait that comes from rand crate, it will be used to generate a random number.
// std is a crate that is built into Rust that doesn't need to be linked with the Cargo.toml file.
// cmp is a method that compares two values, and can be called on anything that can be compared.
// Ordering is a type that is an enum, and the variants, Less, Greater, Equal.
// std crate.
// io is a library that is from std. io stands for input/output.
// let is used to create a variable.
// 'secret_number' is the name of the variable.
// '=' binds the left side of the expression with the right side.
// The rand::thread_rng function gives us the particular random number generator weâ€™re going to use: one that is local to the current thread of execution and is seeded by the operating system.
// The gen_range on the random number generator with the argument passed will generate a random number from 1 to 100, including the lower and higher end.
// The loop keyword creates an infinite loop, running the code inside of the {}.
// 'mut' stands for mutable, a variable is unmutable by default, meaning you can't change the value somewhere else.
// String::new() means to create a new instance of a String.
// Here, we are setting guess, as a mutable variable to the instance of a new String.
// io::stdin is a type that represents a handle to the standard input for the terminal.
// 'read_line' is a method that is being called on the standard input handle to get input from the user.
// We're passing '&mut guess' as the argument to 'read_line; to tell it what string to store the user input in.
// The string argument also needs to be mutable so the method can change the string's content.
// The expect method is an instance of a a Result type.
// If the instance of Result is an 'Err' value, expect will cause the program to crash and display the message that you passed as an argument to the expect.
// If the read_line method returns and Err, it would likely be the result of an error coming from the underlying operating system.
// If the instance of Result is an Ok value, expect will take the return value that Ok is holding and return just that value.
// u32 is declaring a type to the variable. u32 is an unsigned 32 bit number.
// Using a match expression decides what to do next based based on which variant of Ordering was return from the call to cmp with the values in guess and secret_number.
// A match expression is made up of arms. An arm consists of a pattern to match against, and the code that should be run if the value given to match fits that arm's value.
// Rust takes the value given to match and looks through each arm's pattern in turn.
// Patterns and the match construct let you express a variety of situations your code might encounter, and they make sure they handle them all.
// We bind he new variable to the expression 'guess.trim().parse()'.
// The guess in this expression refers to the original guess variable that contained the input as a string.
// The trim method on a String instance will eliminate any whitespace at the beginning and end, which we must do in order to compare the string to the u32, which can only contain numerical values.
// The trim method also removes any '/r/n' which is carriage return and new line.
// The parse mehtod on strings converts a string to another type.
// We need to tell Rust the exact number type we want by uing u32. u32 is a good choose for a small positive number.
// The ':' after the variable name tells rust that we'll annotate the variables type.
// The u32 annotation adn the comparision with 'secret_number' means Rust will infer that 'secret_number' should be a u32 as well.
// The parse method will only work on characters that can logically be converted into numbers, which is why trim is necessary.
// The parse method also returns a Result.
// If the parse method returns an Ok variant and contains a value of num, the expression evaluates to 'num'.
// If the parse method returns an Err variant, the will execute the code 'continue' which tells the program to go to the next iteration of the loop.
// The underscore is a catchall value. Which means no matter what information they have inside them, to match all Err values and ignores them.
// A variable value can be inserted into a string using '{}' with the variable_name storing the value.
// This function compares the value of the variable 'guess' with the value of 'secret_number' by referencing secret_number using a '&'.
// Ordering is another enum that has variants, Less, Greater, and Equal.
//If guess is less than secret_number, println!("Too small!").
//If guess is greater than secret_number, println!("Too big!").
//If guess is equal to than secret_number, println!("You win!").
// Then 'break', which means to exit the loop when the user guesses correctly.

guessing_game>Cargo.toml

# rand is a 'crate library' that will be use to generate a random number.
# A section doesn't end until a section header is placed, and then a new section is created.
# Rust creates a cargo.lock file that to make sure when a new version is released, the code doesn't break.
# The cargo.lock file will store the version that is hard coded into it.


Variables and Mutability:


fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}

This code won't compile. You cannot assign twice to the immutable variable 'x'.

fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}

This code will compile. The code will print:
The value of x is: 5
The value of x is: 6

const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;

Constants are declared using the 'const' keyword.
Constants are always immutable, you cannot use 'mut' on a 'const'.
'let' should be used to declare a variable if the variable might ever be mutable.
The type of the value must be annotated on a const.
Constants are declared in any scope, including the global scope.
A constant must be set to a constant expression. It cannot be set to the result of a value that could only be computed at runtime.
Rust's naming convention for constants is all uppercase with underscores between words.
Constants are valid for the entire time a program runs, within the scope in which they were declared.

fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}

It is possible to declare a new variable with the same name as a previous variable.
This means that the first variable is 'shadowed' by the second variable. Shadowing means that the compiler will use the last declaration as the declaration.
x is first set to 5.
x is then set to 'x + 1', which is equal to six.
This is the last declaration in the scope, so the compiler will see x as 6.
We can do this by using the 'let' keyword again before the name of the variable.
Within an inner scope which is created by the '{}', the is the third declaration of x.
We are creating a new variable called 'x' within the inner scope, which is taking the last declaration of x and multiplying it by 2, to get 12.
When the inner scope ends, the inner shadowing ends, and x returns to being 6.
When we run the program it will print the value of x in the inner scope, and then the value of x in the main scope.
The value of x in the inner scope is: 12
The value of x is: 6
By using 'let' instead of 'mut', we can perform tranformations on a value, but have the variable be immutable after those tranformations are completed.
'mut' is reassigning a variable, while 'shadowing' is transforming a variable.
Another difference between mut and shadowing, is that we can change the type of the value, but still reuse the same name.
For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, and then we want to store that input as a number:
let spaces = "   ";
let spaces = spaces.len();
The first spaces variable is a string type, while the second spaces variable is a number type.
We can't use 'mut' in this situation, because we're not allowed to mutate a variables type.


Data Types:


Every value in Rust is of a certain data type, so that it knows how to work with the data.
Rust is a statically typed language, meaning that is must know the types of all variables at compile time.
The compiler can usually infer what type a variable is based on the value and how it is used.
In cases where many types are possible, such as converting a string to a number using 'parese', we must add a type annotation.

A 'scalar' type represents a single value.
Rust has four primary scalar types: integers, floating-point numbers, booleans, and characters.

An integer is a number without a fractional component. 
Each variant of an integer can be unsigned or signed.
Signed and unsigned refer to whether it's possible for the number to be negative.
If the number needs to have a sign, that means, it can be negative or positive, and is represented with an 'i' plus the bit length, 'i32' for example.
If the number does not need a sign, that means that the number will only ever be positive, and is represent with a 'u' plus the bit length, 'u32' for example.
A signed number will have the same number range as an unsigned number, but the mid-point will be 0, meaning the maximum will only be half of the maximum of an unsigned number with the same bit length.
Integer types in rust include, 8, 16, 32, 64, 128, and size, with a 'u' or 'i' before the number which determines whether the number is signed or unsigned, and the number reffering to the bit length of the number.
The usize and isize types depend on the architecture of the computer the program is running on, 64-bit for 64-bit architecture, and 32-bit for 32-bit architecture.
Integer literals in Rust include, Decimal, Hex, Octal, Binary, and Byte.
An integer literal is a kind of literal for an integer whose value is directly represented in source code.

Deminal can be represented as 123_456_789, which is the same as 123456789, the underscore is added to make it easier to read.
Hex is a base-16 (0-15) and has the prefix 0x.
Octal is a base-8 (0-7) and has the prefex 0o.
Binary is a base-2 (0-1) and has the prefix 0b.
Byte (u8 only) has the prefix b''. The value must be an ASCII character which is contained u8 worth of space.

